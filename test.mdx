## Build the Action Tracker App Using Prompts (with Pica MCP)

This guide shows how to build the Action Tracker app using prompts only. We'll assume your Pica MCP is already configured. We'll focus on:

- **Instant DB**: schema and client setup
- **Minimal API route**: health check placeholder
- **Email sending route via Pica Gmail**: server action/route
- **UI for sending email**: email, name, waitingFor
- **Admin panel UI**: list, filter, and update statuses

Use the following prompts directly in your IDE assistant. Adjust names/paths if your project structure differs.

---

### Prerequisites

- A Next.js app (App Router) with TypeScript
- Pica MCP connected (we'll skip setup here)
- Environment variables prepared for your DB and Pica secret (we'll reference them in prompts)

---

## Zero-start: Create Next App (optional)

If you’re starting fresh, run:

```bash
npx create-next-app@latest action-tracker \
  --ts \
  --app \
  --eslint \
  --tailwind \
  --src-dir false \
  --import-alias "@/*"
cd action-tracker
```

Add required envs to `.env.local`:

```bash
INSTANT_DB_URL=your_db_url
INSTANT_DB_KEY=your_db_key
PICA_SECRET=your_pica_secret
```

---

## Copy-paste reference snippets (to avoid hallucinations)

These minimal examples ensure the prompts have a ground truth.

### instant.schema.ts

```ts
// instant.schema.ts
export type ActionStatus = "pending" | "emailed" | "resolved";

export interface ActionItem {
  id: string; // uuid
  name: string;
  email: string;
  waitingFor: string;
  status: ActionStatus;
  createdAt: number; // epoch ms
}
```

### lib/db.ts (thin client)

```ts
// lib/db.ts
import type { ActionItem, ActionStatus } from "../instant.schema";

const dbUrl = process.env.INSTANT_DB_URL!;
const dbKey = process.env.INSTANT_DB_KEY!;

if (!dbUrl || !dbKey) {
  throw new Error("Missing INSTANT_DB_URL or INSTANT_DB_KEY env");
}

async function request<T>(path: string, init?: RequestInit): Promise<T> {
  const res = await fetch(`${dbUrl}${path}`, {
    ...init,
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${dbKey}`,
      ...(init?.headers || {}),
    },
    cache: "no-store",
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`DB request failed ${res.status}: ${text}`);
  }
  return (await res.json()) as T;
}

export async function createAction(input: {
  name: string;
  email: string;
  waitingFor: string;
}): Promise<ActionItem> {
  const payload = {
    ...input,
    status: "pending" as const,
    createdAt: Date.now(),
  };
  // Replace with your Instant DB create endpoint
  return request<ActionItem>(`/actions`, {
    method: "POST",
    body: JSON.stringify(payload),
  });
}

export async function listActions(filter?: {
  status?: ActionStatus;
}): Promise<ActionItem[]> {
  const query = filter?.status ? `?status=${encodeURIComponent(filter.status)}` : "";
  // Replace with your Instant DB list endpoint
  return request<ActionItem[]>(`/actions${query}`);
}

export async function markActionEmailed(id: string): Promise<ActionItem> {
  // Replace with your Instant DB update endpoint
  return request<ActionItem>(`/actions/${id}`, {
    method: "PATCH",
    body: JSON.stringify({ status: "emailed" as const }),
  });
}

export async function markActionResolved(id: string): Promise<ActionItem> {
  // Replace with your Instant DB update endpoint
  return request<ActionItem>(`/actions/${id}`, {
    method: "PATCH",
    body: JSON.stringify({ status: "resolved" as const }),
  });
}
```

### app/api/health/route.ts (bare minimum)

```ts
// app/api/health/route.ts
import { NextResponse } from "next/server";

export function GET() {
  return NextResponse.json({ ok: true, ts: Date.now() });
}
```

### components/EmailSignup.tsx (attractive, minimal UI)

```tsx
// components/EmailSignup.tsx
"use client";

import { useState } from "react";

export default function EmailSignup() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [waitingFor, setWaitingFor] = useState("");
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState<{ type: "success" | "error"; text: string } | null>(null);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setLoading(true);
    setMessage(null);
    try {
      const res = await fetch("/api/send-email", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, email, waitingFor }),
      });
      if (!res.ok) throw new Error(await res.text());
      setMessage({ type: "success", text: "Email sent! Check your inbox." });
      setName("");
      setEmail("");
      setWaitingFor("");
    } catch (err) {
      setMessage({ type: "error", text: "Failed to send. Please try again." });
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="mx-auto max-w-xl rounded-2xl border border-gray-200 bg-white p-6 shadow-sm dark:border-gray-800 dark:bg-gray-900">
      <h2 className="mb-2 text-2xl font-semibold tracking-tight">Get Started</h2>
      <p className="mb-6 text-sm text-gray-600 dark:text-gray-400">Tell us what you’re waiting for and we’ll email you.</p>
      <form onSubmit={onSubmit} className="space-y-4">
        <div>
          <label htmlFor="name" className="mb-1 block text-sm font-medium">Name</label>
          <input id="name" value={name} onChange={(e) => setName(e.target.value)} required placeholder="Jane Doe" className="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm outline-none ring-0 transition focus:border-gray-900 dark:border-gray-700 dark:bg-gray-950" />
        </div>
        <div>
          <label htmlFor="email" className="mb-1 block text-sm font-medium">Email</label>
          <input id="email" type="email" value={email} onChange={(e) => setEmail(e.target.value)} required placeholder="jane@example.com" className="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm outline-none focus:border-gray-900 dark:border-gray-700 dark:bg-gray-950" />
        </div>
        <div>
          <label htmlFor="waitingFor" className="mb-1 block text-sm font-medium">What are you waiting for?</label>
          <textarea id="waitingFor" value={waitingFor} onChange={(e) => setWaitingFor(e.target.value)} required placeholder="Feature X, invite, docs…" rows={4} className="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm outline-none focus:border-gray-900 dark:border-gray-700 dark:bg-gray-950" />
        </div>
        <button type="submit" disabled={loading} className="inline-flex w-full items-center justify-center rounded-lg bg-black px-4 py-2 text-sm font-medium text-white transition hover:bg-gray-900 disabled:opacity-50">{loading ? "Sending…" : "Send Email"}</button>
        <div aria-live="polite" className="min-h-5 text-sm">
          {message && (
            <p className={message.type === "success" ? "text-green-600" : "text-red-600"}>{message.text}</p>
          )}
        </div>
      </form>
    </div>
  );
}
```

### components/AdminDashboard.tsx (clean admin UI)

```tsx
// components/AdminDashboard.tsx
"use client";

import { useEffect, useMemo, useState } from "react";

type ActionStatus = "pending" | "emailed" | "resolved";
interface ActionItem {
  id: string;
  name: string;
  email: string;
  waitingFor: string;
  status: ActionStatus;
  createdAt: number;
}

export default function AdminDashboard() {
  const [data, setData] = useState<ActionItem[]>([]);
  const [status, setStatus] = useState<ActionStatus | "all">("all");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const filtered = useMemo(
    () => (status === "all" ? data : data.filter((d) => d.status === status)),
    [data, status]
  );

  async function fetchData(currentStatus?: ActionStatus | "all") {
    setLoading(true);
    setError(null);
    try {
      const qs = currentStatus && currentStatus !== "all" ? `?status=${currentStatus}` : "";
      const res = await fetch(`/api/actions${qs}`, { cache: "no-store" });
      if (!res.ok) throw new Error(await res.text());
      const rows = (await res.json()) as ActionItem[];
      setData(rows);
    } catch (err) {
      setError("Failed to load actions");
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    fetchData(status);
  }, [status]);

  async function updateStatus(id: string, next: Exclude<ActionStatus, "pending">) {
    const prev = data;
    setData((rows) => rows.map((r) => (r.id === id ? { ...r, status: next } : r)));
    try {
      const res = await fetch(`/api/actions/${id}/status`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: next }),
      });
      if (!res.ok) throw new Error(await res.text());
    } catch (err) {
      setData(prev);
    }
  }

  return (
    <div className="mx-auto max-w-6xl p-6">
      <div className="mb-6 flex flex-col items-start justify-between gap-3 sm:flex-row sm:items-center">
        <h1 className="text-2xl font-semibold">Admin Dashboard</h1>
        <div className="flex items-center gap-2">
          <label className="text-sm text-gray-600 dark:text-gray-400">Status</label>
          <select value={status} onChange={(e) => setStatus(e.target.value as any)} className="rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm dark:border-gray-700 dark:bg-gray-950">
            <option value="all">All</option>
            <option value="pending">Pending</option>
            <option value="emailed">Emailed</option>
            <option value="resolved">Resolved</option>
          </select>
        </div>
      </div>

      <div className="overflow-hidden rounded-xl border border-gray-200 bg-white shadow-sm dark:border-gray-800 dark:bg-gray-900">
        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-800">
          <thead className="bg-gray-50 dark:bg-gray-950">
            <tr>
              <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">Name</th>
              <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">Email</th>
              <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">Waiting For</th>
              <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">Status</th>
              <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">Created</th>
              <th className="px-4 py-3" />
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200 dark:divide-gray-800">
            {loading ? (
              <tr>
                <td colSpan={6} className="px-4 py-10 text-center text-sm text-gray-500">Loading…</td>
              </tr>
            ) : error ? (
              <tr>
                <td colSpan={6} className="px-4 py-10 text-center text-sm text-red-600">{error}</td>
              </tr>
            ) : filtered.length === 0 ? (
              <tr>
                <td colSpan={6} className="px-4 py-10 text-center text-sm text-gray-500">No actions found</td>
              </tr>
            ) : (
              filtered.map((row) => (
                <tr key={row.id}>
                  <td className="px-4 py-3 text-sm">{row.name}</td>
                  <td className="px-4 py-3 text-sm text-gray-600 dark:text-gray-400">{row.email}</td>
                  <td className="px-4 py-3 text-sm">{row.waitingFor}</td>
                  <td className="px-4 py-3 text-sm">
                    <span className={`inline-flex items-center gap-1 rounded-full px-2 py-1 text-xs ${
                      row.status === "pending"
                        ? "bg-amber-100 text-amber-800 dark:bg-amber-900/30 dark:text-amber-200"
                        : row.status === "emailed"
                        ? "bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-200"
                        : "bg-emerald-100 text-emerald-800 dark:bg-emerald-900/30 dark:text-emerald-200"
                    }`}>
                      {row.status}
                    </span>
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-600 dark:text-gray-400">{new Date(row.createdAt).toLocaleString()}</td>
                  <td className="px-4 py-3 text-right">
                    <div className="flex justify-end gap-2">
                      <button disabled={row.status !== "pending"} onClick={() => updateStatus(row.id, "emailed")} className="rounded-lg border border-blue-200 px-3 py-1.5 text-sm text-blue-700 transition hover:bg-blue-50 disabled:opacity-50 dark:border-blue-900/50 dark:text-blue-300 dark:hover:bg-blue-900/20">Mark Emailed</button>
                      <button disabled={row.status === "resolved"} onClick={() => updateStatus(row.id, "resolved")} className="rounded-lg border border-emerald-200 px-3 py-1.5 text-sm text-emerald-700 transition hover:bg-emerald-50 disabled:opacity-50 dark:border-emerald-900/50 dark:text-emerald-300 dark:hover:bg-emerald-900/20">Mark Resolved</button>
                    </div>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}
```

---

## 1) Prompt: Set up Instant DB schema and client

Use this prompt to create an Instant DB schema and a thin client in `lib/db.ts`.

```text
You are pair-programming with me. Implement a minimal Instant DB setup for a Next.js (App Router, TS) app:

GOALS
- Create a simple schema for an "actions" collection with fields: id (string, uuid), name (string), email (string), waitingFor (string), status ("pending" | "emailed" | "resolved"), createdAt (number, epoch ms)
- Add a light-weight DB client in `lib/db.ts` exposing CRUD helpers:
  - createAction({ name, email, waitingFor }) → creates doc with status "pending"
  - listActions({ status? }) → lists by optional status filter, newest first
  - markActionEmailed(id) → sets status to "emailed"
  - markActionResolved(id) → sets status to "resolved"
- Keep implementation simple and deterministic; prefer explicit typing. Use environment variables for DB URL/keys if needed, e.g. INSTANT_DB_URL, INSTANT_DB_KEY.
- Ensure the file can be imported from server code and React Server Components safely.

DELIVERABLES
- New file `instant.schema.ts` with schema definition
- Update/create `lib/db.ts` with typed helpers
- Add any minimal utility code required. Do not bring in heavy ORMs.

NOTES
- Use high-clarity TypeScript types, no `any`.
- Avoid runtime-heavy abstractions; write straightforward code.
```

---

## 2) Prompt: Add a bare-minimum health route

Create a minimal route at `app/api/health/route.ts` to validate SSR/runtime and serve as a template.

```text
Create `app/api/health/route.ts` with a minimal GET handler that returns JSON `{ ok: true, ts: Date.now() }`. Use Next.js App Router conventions, export `GET` with `NextResponse.json`. Keep it tiny and typed.
```

---

## 3) Prompt: Add API route to send Gmail via Pica

We will add a route `app/api/send-email/route.ts` that:
- Validates payload `{ name, email, waitingFor }`
- Persists an action (status: "pending")
- Sends an email via Pica Gmail
- Marks status "emailed" on success
- Returns a concise JSON result

```text
Add `app/api/send-email/route.ts` with a POST handler that does the following:

REQUIREMENTS
- Accept JSON body: { name: string, email: string, waitingFor: string }
- Validate input; return 400 on invalid
- Create an action in DB via `createAction`
- Use Pica MCP Gmail to send an email:
  - Subject: "Welcome, ${name}!"
  - Body (text): "Thanks for signing up. We got your note about waiting for: ${waitingFor}. We'll be in touch."
  - From: use a connected Gmail account via Pica
  - To: the provided `email`
- On successful send, call `markActionEmailed(id)` and return `{ ok: true, id }`
- On failure, return 500 with an error summary; do not expose secrets

IMPLEMENTATION NOTES
- Use a server-only module for Pica calls if available in this project. Otherwise, add a small helper in `lib/pica.ts` that invokes the Gmail send action given { to, subject, text }.
- Ensure route is edge/runtime-compatible for this project’s defaults.
- Keep logging minimal and safe for server.
```

---

## 4) Prompt: Create UI for sending email

Create a simple client component/form for users to send the email. Place it at `components/EmailSignup.tsx` and render it on the homepage.

```text
Implement a client component `components/EmailSignup.tsx` with a form having fields:
- email (required, email)
- name (required)
- waitingFor (required, textarea)

BEHAVIOR
- On submit, POST to `/api/send-email` with the form data
- Disable submit while pending, show success/error messages
- Minimal, clean styling using Tailwind (if present) or basic CSS classes from the project
- Accessibility: use labels, aria-live for status messages

TYPES
- Define a local type for the payload

INTEGRATION
- Update `app/page.tsx` to import and render `<EmailSignup />`
```

---

## 5) Prompt: Create UI for admin panel

Create an admin dashboard to list actions, filter by status, and update statuses.

```text
Create `components/AdminDashboard.tsx` as a Client Component that allows:

VIEWS
- Table listing actions: name, email, waitingFor, status, createdAt
- Filter by status (all | pending | emailed | resolved)

ACTIONS
- Buttons per row: "Mark Emailed", "Mark Resolved" (disable based on current status)

DATA
- Create two API endpoints:
  - `GET /api/actions?status=...` → returns list
  - `POST /api/actions/{id}/status` with body { status: "emailed" | "resolved" }
- Implement these routes to use `listActions`, `markActionEmailed`, `markActionResolved`

UX
- Optimistic UI updates with graceful fallback on error
- Inline toasts or status indicators
- Keep logic readable and well-typed

INTEGRATION
- Create `app/admin/page.tsx` to render the dashboard. Restrict access later; for now, no auth.
```

---

## 6) Prompt: Wire environment variables and config

Set up the environment variables needed and verify build/runtime.

```text
Add/readme notes for required env vars (do not commit secrets):
- INSTANT_DB_URL=
- INSTANT_DB_KEY=
- PICA_SECRET=

Validate that all server-side modules reading env are only imported server-side. Run dev build to ensure types are sound and routes compile.
```

---

## 7) Prompt: Lightweight QA

Use this to test happy-path flows.

```text
Test plan:
1. Load `/` and submit the email form with valid inputs → expect success toast
2. Confirm DB has a new action with status "emailed"
3. Load `/admin` → see the new row, filter by status
4. Change status to "resolved" → row updates; reload page to confirm persistence
5. Hit `/api/health` → `{ ok: true }` JSON
```

---

### What we skipped

- Pica MCP connection setup and secrets management. Add those per your environment.

### Next steps

- Add auth to `/admin`
- Add pagination and search
- Add HTML email template and analytics
